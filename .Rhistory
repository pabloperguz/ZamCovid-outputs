## Trajectory B prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",2) %>%## give label no. 2 to patients passed through this path
log_(message = "Priority B Patient finished Arm 2!" )
,
trajectory("C") %>%
## Trajectory C prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",3) %>%## give label no. 3 to patients passed through this path
log_(message = "Priority C Patient finished Arm 3!" )
)
env %>%
add_resource("doctor", 3) %>%
add_generator("patient", patient, function() 5, mon=2)
env %>%
run(until=600)
})
#arriv<-get_mon_arrivals(envs)
#resourc<-get_mon_resources(envs)
attr<-get_mon_attributes(envs)
table(attr$value)
resources <- get_mon_resources(envs)
p1=plot(resources, metric = "utilization")
p2=plot(resources, metric = "usage", c("nurse", "doctor","administration"),
items = c( "queue", "server"))
arrivals <- get_mon_arrivals(envs)
p3=plot(arrivals, metric = "waiting_time")
p4=plot(arrivals, metric = "activity_time")
grid.arrange(p1,p2,p3,p4)
plot(patient, verbose = T)
envs <- lapply(1:100, function(i) {
env <- simmer("hospital")
patient <- trajectory("patients' path") %>%
branch(function() sample(c(1,2,3),size=1,replace=T,prob=c(0.1,0.5,0.4)),
continue=c(T,T,T),
trajectory("A") %>%
## Trajectory A prioritization
# c(1st value = priority, preemptible level must be larger, restart=T/F)
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
## give label no. 1 to patients passed through this path
set_attribute("Arm",1)  %>%
log_(message = "Priority A Patient finished Arm 1 !" )
,
trajectory("B") %>%
## Trajectory B prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",2) %>%## give label no. 2 to patients passed through this path
log_(message = "Priority B Patient finished Arm 2!" )
,
trajectory("C") %>%
## Trajectory C prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",3) %>%## give label no. 3 to patients passed through this path
log_(message = "Priority C Patient finished Arm 3!" )
)
env %>%
add_resource("doctor", 5) %>%
add_generator("patient", patient, function() 5, mon=2)
env %>%
run(until=600)
})
#arriv<-get_mon_arrivals(envs)
#resourc<-get_mon_resources(envs)
attr<-get_mon_attributes(envs)
table(attr$value)
table(attr$replication, attr$value)
resources <- get_mon_resources(envs)
p1=plot(resources, metric = "utilization")
p2=plot(resources, metric = "usage", c("nurse", "doctor","administration"),
items = c( "queue", "server"))
arrivals <- get_mon_arrivals(envs)
p3=plot(arrivals, metric = "waiting_time")
p4=plot(arrivals, metric = "activity_time")
grid.arrange(p1,p2,p3,p4)
envs <- lapply(1:100, function(i) {
env <- simmer("hospital")
patient <- trajectory("patients' path") %>%
branch(function() sample(c(1,2,3),size=1,replace=T,prob=c(0.1,0.5,0.4)),
continue=c(T,T,T),
trajectory("A") %>%
## Trajectory A prioritization
# c(1st value = priority, preemptible level must be larger, restart=T/F)
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
## give label no. 1 to patients passed through this path
set_attribute("Arm",1)  %>%
log_(message = "Priority A Patient finished Arm 1 !" )
,
trajectory("B") %>%
## Trajectory B prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",2) %>%## give label no. 2 to patients passed through this path
log_(message = "Priority B Patient finished Arm 2!" )
,
trajectory("C") %>%
## Trajectory C prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",3) %>%## give label no. 3 to patients passed through this path
log_(message = "Priority C Patient finished Arm 3!" )
)
env %>%
add_resource("doctor", 4) %>%
add_generator("patient", patient, function() 5, mon=2)
env %>%
run(until=600)
})
#arriv<-get_mon_arrivals(envs)
#resourc<-get_mon_resources(envs)
attr<-get_mon_attributes(envs)
table(attr$value)
table(attr$replication, attr$value)
resources <- get_mon_resources(envs)
p1=plot(resources, metric = "utilization")
p2=plot(resources, metric = "usage", c("nurse", "doctor","administration"),
items = c( "queue", "server"))
arrivals <- get_mon_arrivals(envs)
p3=plot(arrivals, metric = "waiting_time")
p4=plot(arrivals, metric = "activity_time")
grid.arrange(p1,p2,p3,p4)
envs <- lapply(1:1000, function(i) {
env <- simmer("hospital")
patient <- trajectory("patients' path") %>%
branch(function() sample(c(1,2,3),size=1,replace=T,prob=c(0.1,0.5,0.4)),
continue=c(T,T,T),
trajectory("A") %>%
## Trajectory A prioritization
# c(1st value = priority, preemptible level must be larger, restart=T/F)
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
## give label no. 1 to patients passed through this path
set_attribute("Arm",1)  %>%
log_(message = "Priority A Patient finished Arm 1 !" )
,
trajectory("B") %>%
## Trajectory B prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",2) %>%## give label no. 2 to patients passed through this path
log_(message = "Priority B Patient finished Arm 2!" )
,
trajectory("C") %>%
## Trajectory C prioritization
set_prioritization(values = c(3,7,T)) %>%
## add a consultation activity
seize("doctor", 1) %>%
timeout(function() rnorm(1, 20)) %>%
release("doctor", 1) %>%
set_attribute("Arm",3) %>%## give label no. 3 to patients passed through this path
log_(message = "Priority C Patient finished Arm 3!" )
)
env %>%
add_resource("doctor", 4) %>%
add_generator("patient", patient, function() 5, mon=2)
env %>%
run(until=600)
})
#arriv<-get_mon_arrivals(envs)
#resourc<-get_mon_resources(envs)
attr<-get_mon_attributes(envs)
table(attr$value)
table(attr$replication, attr$value)
resources <- get_mon_resources(envs)
table(attr$value)
p1=plot(resources, metric = "utilization")
p2=plot(resources, metric = "usage", c("nurse", "doctor","administration"),
items = c( "queue", "server"))
arrivals <- get_mon_arrivals(envs)
p3=plot(arrivals, metric = "waiting_time")
p4=plot(arrivals, metric = "activity_time")
grid.arrange(p1,p2,p3,p4)
View(resources)
patients <- get_mon_attributes(envs)
View(patients)
plot(patients, metric = "value")
arriv<-get_mon_arrivals(envs)
resourc<-get_mon_resources(envs)
attr<-get_mon_attributes(envs)
arr_per_res<-get_mon_arrivals(envs, T)
table(attr$value)
table(attr$replication, attr$value)
resources<-get_mon_resources(envs)
p1=plot(resources, metric = "utilization")
p2=plot(resources, metric = "usage", c("nurse", "doctor","administration"),
items = c( "queue", "server"))
arrivals <- get_mon_arrivals(envs)
p3=plot(arrivals, metric = "waiting_time")
p4=plot(arrivals, metric = "activity_time")
grid.arrange(p1,p2,p3,p4)
install.packages("triangle")
options(scipen = 999)
start.time<-Sys.time() ## start stopwatch
mydata<-lapply(1:1000, function(i) {
## Net Profit = Sales Volume * (Selling Price - Unit cost) - Fixed costs
## create random uniform integer for SalesVolume
DU = sample(x=1:3,size = 1,replace = T)
if(DU==1){
SalesVolume=100000
SellingPrice=8
}
if(DU==2){
SalesVolume=75000
SellingPrice=10
}
if(DU==3){
SalesVolume=50000
SellingPrice=11
}
## create triangular distribution for unit cost (as per example)
library(triangle)
Unitcost = rtriangle(1,5.5,7.5,c = 6.5) ## c=mode of distribution
#### hist(rtriangle(10000000,5.5,7.5))
Fixedcosts = 120000
NetProfit = SalesVolume * (SellingPrice - Unitcost) - Fixedcosts
})
View(mydata)
stop.time<-Sys.time() ## stop stopwatch
time.taken.lapply = stop.time-start.time
LApply_NetProfits = unlist(mydata)
hist(LApply_NetProfits)
mean(LApply_NetProfits)
summary(LApply_NetProfits)
start.time.fl<-Sys.time() ## start stopwatch
NetProfits=vector(mode="numeric")   ## mind the "s"
SalesVolumes = vector(mode="numeric")
UnitCosts = vector(mode="numeric")
SellingPrices = vector(mode="numeric")
for(i in 1:10000) {
## Net Profit = Sales Volume * (Selling Price - Unit cost) - Fixed costs
## create random uniform integer for SalesVolume
DU = sample(x=1:3,size = 1,replace = T)
if(DU==1){
SalesVolume=100000
SellingPrice=8
}
if(DU==2){
SalesVolume=75000
SellingPrice=10
}
if(DU==3){
SalesVolume=50000
SellingPrice=11
}
## create triangular distribution for unit cost (as per example)
library(triangle)
Unitcost = rtriangle(1,5.5,7.5,c = 6.5) ## c=mode of distribution
#### hist(rtriangle(10000000,5.5,7.5))
Fixedcosts = 120000
NetProfit = SalesVolume * (SellingPrice - Unitcost) - Fixedcosts
NetProfits[i]=NetProfit
SalesVolumes[i] = SalesVolume
UnitCosts[i] = Unitcost
SellingPrices[i] = SellingPrice
}
stop.time.fl<-Sys.time() ## start stopwatch
time.taken.fl <-stop.time.fl - start.time.fl
time.taken.fl
time.taken.lapply
time.taken.fl - time.taken.lapply
par(mfrow = c(2,2))
hist(SalesVolumes)
hist(SellingPrices)
hist(UnitCosts)
hist(NetProfits)
abline(v=mean(NetProfits), col=2)
summary(SalesVolumes)
summary(SellingPrices)
summary(UnitCosts)
summary(NetProfits)
par(mfrow = c(1,1))
mydata<-c(1,   0,   0,   0,
0.5, 0,   0.5, 0,
0,   0.5, 0,   0.5,
0,   0,   0,   1)
## convert vector to matrix
mydata
mytm<-matrix(data = mydata, byrow = T, ncol=4)
mytm
P2 = mytm %*% mytm  ## if use mytm * mytm or mytm^2 rows will not add to 1
library(expm)
mytm%^%2
P10 =  mytm %*% mytm %*% mytm %*% mytm %*% mytm%*% mytm %*% mytm%*% mytm %*% mytm%*% mytm
library(expm)
mytm10 <- mytm%^%10
mytm10
rounded_mytm10<-round(mytm10,2)
row.names(rounded_mytm10)<-c("0$","25$","50$","75$")
colnames(rounded_mytm10)<-c("0$","25$","50$","75$")
rounded_mytm10
## lets look at results
install.packages("markovchain")
library(markovchain)
gambler <- new("markovchain", states = c("0$", "25$", "50$", "75$"),
transitionMatrix = matrix(data = c(1, 0, 0, 0,
0.5, 0, 0.5, 0,
0, 0.5, 0, 0.5,
0, 0, 0, 1), byrow = T, nrow = 4),
name = "Gambler")
print(gambler)
plot(gambler)
after2trials <- gambler * gambler
after2trials
after1000trial <- gambler ^ 1000
after1000trial
mtx<-after1000trial[1:4]
round(mtx,2)
set.seed(42)
set.seed(1234)
drat:::add("ncov-ic")
install.packages("drat")
drat:::add("ncov-ic")
install.packages("sircovid")
browseVignettes("sircovid")
remotes::install_github("mrc-ide/sircovid", build_vignettes = TRUE)
install.packages("remotes")
remotes::install_github("mrc-ide/sircovid", build_vignettes = TRUE)
install.packages(c("cmprsk", "dplyr", "epiR", "fitdistrplus", "ggsci", "jtools", "plotly", "plyr", "qwraps2", "survminer", "tidyverse", "trend"))
install.packages(c("gridExtra", "simmer", "simmer.plot"))
install.packages(c("gridExtra", "simmer", "simmer.plot"))
install.packages("xlsx")
install.packages("drat")
drat:::add("mrc-ide")
install.packages("didehpc")
source("https://mrc-ide.github.io/didehpc/install")
install.packages("provisionr")
install.packages("withr")
drat:::add("ncov-ic")
install.packages("sircovid2")
install.packages("withr")
install.packages("withr")
drat:::add("ncov-ic")
install.packages(c("dust", "mcstate"))
install.packages(c("MASS", "mgcv", "nlme", "survival", "withr"))
library(withr)
drat:::add("ncov-ic")
install.packages(c("dust", "mcstate"))
drat:::add("ncov-ic")
install.packages("sircovid2")
source("https://mrc-ide.github.io/didehpc/install")
library(didehpc)
drat:::add("mrc-ide")
install.packages("didehpc")
install.packages("didehpc")
remotes::install_github("mrc-ide/odin")
remotes::install_github("mrc-ide/odin.dust")
remotes::install_github("mrc-ide/odin"
)
install.packages("withr")
install.packages("withr")
install.packages("withr")
install.packages("devtools")
install.packages("knitr")
install.packages("withr")
install.packages("withr")
install.packages('socialmixr')
install.packages("withr")
install.packages("withr")
install.packages("withr", type = "source")
remotes::install_github("mrc-ide/odin")
remotes::install_github("mrc-ide/odin.dust")
drat:::add("vimc")
install.packages("orderly")
knitr::opts_chunk$set(echo = TRUE)
## Preparation
yt<-c(0,1,1,1,2) #observed data
set.seed(122018)
#SMC by the bootstrap filter
BF_sim<-function(yt,sig,merror,size){
tlen<-length(yt)
xt<-matrix(0,tlen,size)
xt_prop<-matrix(0,tlen,size)
avg_wt<-numeric(tlen)
avg_wt[1]=1
for(t in 2:tlen){
xt_prop[t,]<-rnorm(size,xt[t-1,],sig) #proposal particles
weights=pnorm(yt[t]+0.5,xt_prop[t,],merror)-pnorm(yt[t]-0.5,xt_prop[t,],merror) #weighted by p(yt|xt_prop)
avg_wt[t]=sum(weights)/size
if(sum(weights)==0)weights=weights+1 #marginal likelihood 0: avoid error in sample() below due to weights=0
ind<-sample(size,size,replace=T,prob=weights) #resample
xt[1:t,]=rbind(xt[1:(t-1),ind],xt_prop[t,ind])
}
return(list(xt=xt,xt_prop=xt_prop,avg_wt=avg_wt))
}
sig=0.5
merror=0.1
xt_prior<-apply(rbind(0,matrix(rnorm(10000,0,sig),4)),2,cumsum) #prior samples of xt
xt_BF<-BF_sim(yt,sig,merror,10000)
xt_posterior<-xt_BF$xt#posterior samples of x_t
xt_prop<-xt_BF$xt_prop
View(xt_prior)
View(xt_BF)
View(xt_posterior)
## Figure 1. Trajectories of x_t
par(mfrow=c(1,2))
matplot(xt_prior,type="l",lty=1,ylim=c(-3,3),ylab="hidden state",xlab="time")
matplot(xt_posterior[,1:500],type="l",lty=1,ylim=c(-3,3),main="",ylab="hidden state",xlab="time")
## Figure 2. Posterior distribution p(x|y)
par(mfrow=c(1,4),cex=1)
for(i in 2:5){
hist(xt_posterior[i,],xlab=paste0("x",i),main="",breaks=15,col="gray",freq=F,ylim=c(0,2))
abline(v=c(0,1,1,1,2)[i],col="red")
}
View(xt_prior)
set.seed(122018)
xt_BF<-BF_sim(yt,sig,merror=0.1,200) #SMC
xt_posterior<-xt_BF$xt #posterior samples of xt
xt_prop<-xt_BF$xt_prop #proposed particles at each time step
## Figure 3. Sequential sampling of trajectories x
par(mfrow=c(2,4))
for(t in 2:5){ #plot trajectories
matplot(rbind(xt_posterior[1:(t-1),],xt_prop[t,],matrix(NA,5-t,ncol(xt_posterior))),type="l",lty=1,ylim=c(-1,3),ylab="hidden state",xlab="time")
matplot(rbind(xt_posterior[1:t,],matrix(NA,5-t,ncol(xt_posterior))),type="l",lty=1,ylim=c(-1,3),ylab="hidden state",xlab="time")
}
set.seed(122018)
tlen<-5 # total time steps
mcmclen<-5000 # Iterations in MCMC
nparticle<-200 # Particles used in SMC
merror=0.1 #measurement error
# Initialise MCMC
sig_mcmc<-numeric(mcmclen) #sigma
sig_mcmc[1]=1
ll<-numeric(mcmclen) #log-likelihood
ll[1]=-Inf
x_mcmc<-matrix(0,mcmclen,tlen) #x_t
prop_sd<-0.5 #sd of proposal distribution
# PMCMC
for(n in 2:mcmclen){
sig_prop<-sig_mcmc[n-1]+rnorm(1,0,prop_sd)
sig_prop=abs(sig_prop)
BF<-BF_sim(yt,sig_prop,merror,nparticle)
ll_prop<-sum(log(BF$avg_wt))
prob_update<-min(1,exp(ll_prop-ll[n-1]))
if(runif(1)<prob_update){
sig_mcmc[n]=sig_prop
x_mcmc[n,]=BF$xt[,sample(nparticle,1)]
ll[n]=ll_prop
}else{
sig_mcmc[n]=sig_mcmc[n-1]
x_mcmc[n,]=x_mcmc[n-1,]
ll[n]=ll[n-1]
}
}
## Figure 4. PMCMC results
par(mfrow=c(2,2))
# MCMC chain for sigma
plot(sig_mcmc,type="l",xlab="iteration",ylab="sigma")
# Posterior distribution for sigma
hist(sig_mcmc[-(1:1000)],breaks=100,freq=F,main="",xlab="sigma",border="dimgray")
# Median and 95% Credible intervals
abline(v=quantile(sig_mcmc[-(1:1000)],c(0.025,0.5,0.975)),lty=c(2,1,2),lwd=2,col=1)
# Posterior samples of X_1:5
matplot(t(x_mcmc[-(1:1000),]),type="l",lty=1,ylim=c(-1,3),ylab="hidden state",xlab="time")
numeric(mcmclen)
View(x_mcmc)
sig_mcmc
y <- rexp(23,1)
h <- 0.79 * IQR(y) * length(y) ^ (-1/5)
ans <- Erlang(y,90,h)
plot(ans, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")
y <- rexp(23,1)
h <- 0.79 * IQR(y) * length(y) ^ (-1/5)
ans <- Erlang(y,90,h)
install.packages("DELTD")
library(DELTD)
ans <- Erlang(y,90,h)
plot(ans, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")
## To add true density along with estimated
d1<-density(y,bw=h)
lines(d1,type="p",col="red")
legend("topright", c("Real Density", "Density by Erlang Kernel"), col=c("red", "black"), lty=c(1,2))
plot(ans, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")
deaths_by_age <- readRDS("~/R_Projects/ncov-outputs/draft/rtm_inference_pmcmc_spim_fits/20210303-191439-5cbf0a2f/outputs/deaths_by_age.rds")
View(deaths_by_age)
deaths_by_age <- readRDS("~/R_Projects/ncov-outputs/draft/rtm_inference_pmcmc_spim_fits/20210303-191920-38dd4b39/outputs/deaths_by_age.rds")
View(deaths_by_age)
setwd("~/R_Projects/ZamCovid-outputs")
